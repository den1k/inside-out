<!DOCTYPE html>
<html><head><title>inside-out: a Clojure forms library</title><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1" name="viewport"><script src="https://cdn.tailwindcss.com?plugins=typography" type="text/javascript"></script><script>tailwind.config = {
  darkMode: "class",
  content: ["./public/build/index.html", "./public/build/**/*.html", "./build/viewer.js"],
  safelist: ['dark'],
  theme: {
    extend: {},
    fontFamily: {
      sans: ["Fira Sans", "-apple-system", "BlinkMacSystemFont", "sans-serif"],
      serif: ["PT Serif", "serif"],
      mono: ["Fira Mono", "monospace"]
    }
  },
  variants: {
    extend: {},
  },
  plugins: [],
}
</script><style type="text/tailwindcss">@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  html {
    font-size: 18px;
  }
  @media (max-width: 600px) {
    html {
      font-size: 16px;
    }
  }
  .font-condensed { font-family: "Fira Sans Condensed", sans-serif; }
  .font-inter     { font-family: "Inter", sans-serif; }
  body {
    @apply font-serif antialiased text-gray-900 sm:overscroll-y-none;
  }
  code, .code {
    @apply font-mono text-sm text-gray-900 bg-slate-50 px-0.5 py-px rounded dark:bg-gray-800;
  }
  code::before, code::after { @apply content-none !important; }
  h1, h2, h3, h4, h5, h6 {
    @apply font-condensed font-bold mt-8 first:mt-0;
  }
  h1 { @apply text-4xl; }
  h2 { @apply text-3xl; }
  h3 { @apply text-2xl; }
  h4 { @apply text-xl; }
  h5 { @apply text-lg; }
  h6 { @apply text-base; }

  button { @apply focus:outline-none; }
  strong { @apply font-bold; }
  em     { @apply italic; }
  pre    { @apply m-0 font-mono; }
}

/* Compatibility */
/* --------------------------------------------------------------- */
/* TODO: Verify which colors are in use and replace with Tailwind
   colors accordingly. Move Nj-specific styles out of here. */

:root {
  --teal-color: #31afd0;
  --dark-teal-color: #095960;
  --near-black-color: #2e2e2c;
  --red-color: #d64242;
  --dark-blue-color: #1f2937;
  --dark-blue-60-color: rgba(28, 42, 56, 0.6);
  --gray-panel-color: rgba(239, 241, 245, 1.000);
  --brand-color: var(--dark-blue-color);
  --link-color: #5046e4;
  --command-bar-selected-color: var(--teal-color);
}

.serif      { @apply font-serif; }
.sans-serif { @apply font-sans; }
.monospace  { @apply font-mono; }
.inter      { @apply font-inter; }

.border-color-teal { border-color: var(--dark-teal-color); }
.teal { color: var(--teal-color); }
.bg-dark-blue { background: var(--dark-blue-color); }
.bg-dark-blue-60 { background: rgba(28, 42, 56, 0.6); }
.bg-gray-panel { background: var(--gray-panel-color); }
.text-dark-blue  { color: var(--dark-blue-color); }
.text-dark-blue-60 { color: var(--dark-blue-60-color); }
.border-dark-blue-30 { border-color: rgba(28, 42, 56, 0.6); }
.text-brand { color: var(--dark-blue-color); }
.bg-brand { background: var(--dark-blue-color); }
.text-selected { color: white; }
.red { color: var(--red-color); }

/* Disclose Button */
/* --------------------------------------------------------------- */

.disclose {
  @apply content-none border-solid cursor-pointer inline-block relative mr-[3px] top-[-2px] transition-all;
  border-color: var(--near-black-color) transparent;
  border-width: 6px 4px 0;
}
.disclose:hover {
  border-color: var(--near-black-color) transparent;
}
.dark .disclose,
.dark .disclose:hover {
  border-color: white transparent;
}
.disclose.collapsed {
  @apply rotate-[-90deg];
}

/* Layout */
/* --------------------------------------------------------------- */

.page {
  @apply max-w-5xl mx-auto px-12 box-border flex-shrink-0;
}
.max-w-prose { @apply max-w-[46rem] !important; }
.max-w-wide  { @apply max-w-3xl !important; }

/* List Styles */
/* --------------------------------------------------------------- */

.task-list-item + .task-list-item,
.viewer-markdown ul .task-list-item ul {
  @apply mt-1;
}

/* compact TOC */
.viewer-markdown .toc ul {
  list-style: none;
  @apply my-0;
}

/* Code Viewer */
/* --------------------------------------------------------------- */

.viewer-code {
  @apply font-mono bg-slate-100 rounded-sm text-sm mt-4 overflow-x-auto dark:bg-gray-800;
}
.viewer-code .cm-content {
  @apply py-4 px-8;
}
@media (min-width: 960px){
  .viewer-notebook .viewer-code .cm-content {
    @apply py-4 pl-12;
  }
}
/* Donâ€™t show focus outline when double-clicking cell in Safari */
.cm-scroller { @apply focus:outline-none; }

/* Syntax Highlighting */
/* --------------------------------------------------------------- */

.inspected-value { @apply text-xs font-mono leading-[1.25rem]; }
.cmt-strong, .cmt-heading { @apply font-bold; }
.cmt-emphasis { @apply italic; }
.cmt-strikethrough { @apply line-through; }
.cmt-link { @apply underline; }
.untyped-value { @apply whitespace-nowrap; }

.cm-editor, .cmt-default, .viewer-result {
  @apply text-slate-800 dark:text-slate-300;
}
.cmt-keyword {
  @apply text-purple-800 dark:text-pink-400;
}
.cmt-atom, .cmt-bool, .cmt-url, .cmt-contentSeparator, .cmt-labelName {
  @apply text-blue-900 dark:text-blue-300;
}
.cmt-inserted, .cmt-literal {
  @apply text-emerald-700 dark:text-emerald-200;
}
.cmt-string, .cmt-deleted {
  @apply text-rose-700 dark:text-sky-300;
}
.cmt-regexp, .cmt-escape {
  @apply text-orange-500 dark:text-orange-300;
}
.cmt-variableName {
  @apply text-blue-800 dark:text-sky-300;
}
.cmt-typeName, .cmt-namespace {
  @apply text-emerald-600 dark:text-emerald-300;
}
.cmt-className {
  @apply text-teal-600 dark:text-teal-200;
}
.cmt-macroName {
  @apply text-teal-700 dark:text-teal-200;
}
.cmt-propertyName {
  @apply text-blue-700 dark:text-blue-200;
}
.cmt-comment {
  @apply text-slate-500 dark:text-slate-400;
}
.cmt-meta {
  @apply text-slate-600 dark:text-slate-400;
}
.cmt-invalid {
  @apply text-red-500 dark:text-red-300;
}

.result-data {
  @apply font-mono text-sm overflow-x-auto whitespace-nowrap leading-normal;
}
.result-data::-webkit-scrollbar, .path-nav::-webkit-scrollbar {
  @apply h-0;
}
.result-data-collapsed {
  @apply whitespace-nowrap;
}
.result-data-field {
  @apply ml-4 whitespace-nowrap;
}
.result-data-field-link{
  @apply ml-4 whitespace-nowrap cursor-pointer;
}
.result-data-field-link:hover {
  @apply text-black bg-black/5;
}
.result-text-empty {
  color: rgba(0,0,0,.3);
}
.browsify-button:hover {
  box-shadow: -2px 0 0 2px #edf2f7;
}

/* Prose */
/* --------------------------------------------------------------- */

.viewer-notebook,
.viewer-markdown {
  @apply prose
    dark:prose-invert
    prose-a:text-blue-600 prose-a:no-underline hover:prose-a:underline
    dark:prose-a:text-blue-300
    prose-p:mt-4 prose-p:leading-snug
    prose-ol:mt-4 prose-ol:mb-6 prose-ol:leading-snug
    prose-ul:mt-4 prose-ul:mb-6 prose-ul:leading-snug
    prose-blockquote:mt-4 prose-blockquote:leading-snug
    prose-hr:mt-6 prose-hr:border-t-2 prose-hr:border-solid prose-hr:border-slate-200
    prose-figure:mt-4
    prose-figcaption:mt-2 prose-figcaption:text-xs
    prose-headings:mb-6
    prose-th:mb-0
    prose-img:mb-0
    prose-code:font-medium prose-code:bg-slate-100
    max-w-none;
}
.viewer-markdown li > p {
  @apply inline;
}

/* Todo Lists */
/* --------------------------------------------------------------- */

.contains-task-list {
  @apply pl-6 list-none;
}
.contains-task-list li p {
  @apply inline m-0;
}
.contains-task-list input[type="checkbox"] {
  @apply appearance-none h-4 w-4 rounded border border-slate-200 relative mr-[0.3rem] ml-[-1.5rem] top-[0.15rem];
}
.contains-task-list input[type="checkbox"]:checked {
  @apply border-indigo-600 bg-indigo-600 bg-no-repeat bg-contain;
  background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
}

/* Markdown TOC */
/* --------------------------------------------------------------- */

.viewer-markdown .toc      { @apply mt-4; }
.viewer-markdown h1 + .toc { @apply mt-8; }

.viewer-markdown .toc h1,
.viewer-markdown .toc h2,
.viewer-markdown .toc h3,
.viewer-markdown .toc h4,
.viewer-markdown .toc h5,
.viewer-markdown .toc h6 {
  @apply text-base text-indigo-600 font-sans my-0;
}
.viewer-markdown .toc a {
  @apply text-indigo-600 font-normal no-underline hover:underline;
}
.viewer-markdown .toc li    { @apply m-0; }
.viewer-markdown .toc ul ul { @apply pl-4; }

/* Notebook Spacing */
/* --------------------------------------------------------------- */

.viewer-notebook { @apply py-16; }
.viewer-markdown *:first-child:not(.viewer-code) { @apply mt-0; }
.viewer + .viewer { @apply mt-6; }
.viewer-markdown + .viewer { @apply mt-3; }
.viewer-markdown + .viewer-markdown { @apply mt-0; }

/* Sidenotes */
/* --------------------------------------------------------------- */

.sidenote-ref {
  @apply top-[-3px] inline-flex justify-center items-center w-[18px] h-[18px]
    rounded-full bg-slate-100 border border-slate-300 hover:bg-slate-200 hover:border-slate-300
    m-0 ml-[4px] cursor-pointer;
}
.sidenote {
  @apply hidden float-left clear-both mx-[2.5%] my-4 text-xs relative w-[95%];
}
.sidenote-ref.expanded + .sidenote {
  @apply block;
}
@media (min-width: 860px) {
  .sidenote-ref {
    @apply top-[-0.5em] w-auto h-auto inline border-0 bg-transparent m-0 pointer-events-none;
  }
  .sidenote sup { @apply inline; }
  .viewer-markdown .contains-sidenotes p { @apply max-w-[65%]; }
  .viewer-markdown p .sidenote {
    @apply mr-[-54%] mt-[0.2rem] w-1/2 float-right clear-right relative block;
  }
}
.viewer-code + .viewer:not(.viewer-markdown):not(.viewer-code):not(.viewer-code-folded),
.viewer-code-folded + .viewer:not(.viewer-markdown):not(.viewer-code):not(.viewer-code-folded),
.viewer-result + .viewer-result {
  @apply mt-2;
}
.viewer-result {
  @apply leading-tight;
}
@media (min-width: 768px) {
  .devcard-desc > div {
    @apply max-w-full m-0;
  }
}

/* Command Palette */
/* --------------------------------------------------------------- */

.nj-commands-input {
  @apply bg-transparent text-white;
}
.nj-context-menu-item:hover:not([disabled]) {
  @apply cursor-pointer;
  background-color: rgba(255,255,255,.14);
}

/* Devdocs */
/* --------------------------------------------------------------- */

.logo, .logo-white {
  @apply block indent-[-999em];
  background: url(/images/nextjournal-logo.svg) center center no-repeat;
}
.devdocs-body {
  @apply font-inter;
}

/* Workarounds */
/* --------------------------------------------------------------- */

/* Fixes vega viewer resizing into infinity */
.vega-embed .chart-wrapper { @apply h-auto !important; }
/* fixes fraction separators being overridden by twâ€™s border-color */
.katex * { @apply border-black; }
</style><script src="/js/main.js" type="text/javascript"></script><link href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&amp;family=Fira+Mono:wght@400;700&amp;family=Fira+Sans+Condensed:ital,wght@0,700;1,700&amp;family=Fira+Sans:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&amp;family=PT+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet" type="text/css"></head><body><div id="clerk-static-app"></div><script>let viewer = nextjournal.clerk.sci_viewer
let app = nextjournal.clerk.static_app
let opts = viewer.read_string("{:paths [\"dev/inside_out/notebook.cljc\"], :bundle? false, :browse? false, :out-path \"public\", :path->doc {\"dev/inside_out/notebook.cljc\" {:nextjournal/value {:blocks [{:nextjournal/value \" # inside-out: a Clojure forms library\\n\\n The job of a form is to collect some input from a user, so that we can do something with it.\\n\\n The purpose of this library is to provide a simple and efficient way to write forms without\\n error-prone repetition, while avoiding the perils of \\\"bad magic\\\" - abstractions that do too much,\\n and are hard to understand or customize later.\\n\\n Further, we want to enable good user experiences by making it easy to offer clear instructions\\n and feedback to users as they complete a form.\\n\\n The two main ideas behind our approach are the \\\"inside-out\\\" syntax, and \\\"attribute-driven\\\" metadata.\\n\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Before we begin, we need to set up our namespace. You can mostly ignore this, the important bits are\\n `[inside-out.forms :as forms]` and `[inside-out.reagent :refer [with-form]]`\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"^#:nextjournal.clerk{:toc? true :no-cache true}\\n(ns inside-out.notebook\\n  (:require [inside-out.forms :as forms]\\n            [inside-out.reagent :refer [with-form]]\\n\\n   ;; only for notebook purposes\\n            [clojure.string :as str]\\n            [inside-out.clerk-ui :as ui :refer [hiccup]]\\n            [kitchen-async.promise :as p]))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:render-fn #viewer-fn (fn [_] (v/html [:span.cmt-default.inspected-value \\\"nil\\\"]))}}\"}, :path []} {:nextjournal/value \" ## Syntax Quickstart\\n\\n With `inside-out`, we first describe the \\\"shape\\\" of data you want, and then we get\\n some \\\"primitives\\\" that can be used to build user-input components of any kind.\\n\\n Here we create a `contact-info` form containing a map with the fields `?name` and `?email`:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [contact-info {:name ?name\\n                          :email ?email}]\\n  (reset! ?name \\\"Peter Rabbit\\\")\\n  @contact-info)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :email, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value nil, :nextjournal/viewer {:render-fn #viewer-fn (fn [_] (v/html [:span.cmt-default.inspected-value \\\"nil\\\"]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value \\\"Peter Rabbit\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\"), :fetch-opts {:n 10}}}\", :nextjournal/viewer {:name :map}}, :path []} {:nextjournal/value \" Things to note:\\n - `?name` and `?email` are *fields* because they start with a `?`.\\n - Fields behave like atoms, so we can `deref` and `reset!` them.\\n - Fields come from the \\\"insides\\\" of the form, but they are lifted \\\"out\\\"\\n   into scope so that you can access them individually. Hence the name, inside-out.\\n - When we deref a form, its value is computed using the current values of its fields.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" How do we build a real form, that takes user input?\\n Let's start with an `:input` element for `?name`:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(hiccup\\n  (with-form [contact-info {:name ?name\\n                            :email ?email}]\\n    [:div\\n     [:input.border\\n      {:value @?name\\n       :on-change (fn [event] (reset! ?name (.. event -target -value)))}]\\n     [:pre (str @contact-info)]]))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value {:reagent/var inside-out.notebook/reagent-view-1214806481}, :nextjournal/width :wide, :nextjournal/viewer {:render-fn #viewer-fn (fn render-var [{var :reagent/var}] (let [path (->> (str/split (str var) #\\\"[./]\\\") (mapv munge)) reagent-fn (applied-science.js-interop/get-in js/window path)] (when reagent-fn (v/html [:div.m-1 [reagent-fn]]))))}}\"}, :path [], :nextjournal/width :wide} {:nextjournal/value \" Try typing in the box above to see how it works.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Using this basic pattern of `@deref` to read the current value, and `reset!` to change it,\\n we can already build any kind of input component, and have the results compose into the\\n data structure we need.\\n\\n A form doesn't need to be a map; it can be any kind of expression at all.\\n For example, a Datomic/DataScript transaction...\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [tx [[:db/add 1 :person/name ?name]]]\\n  (reset! ?name \\\"Blythe\\\")\\n  @tx)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :db/add, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value 1, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2], :nextjournal/value :person/name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 3], :nextjournal/value \\\"Blythe\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :closing-paren (\\\"]\\\" \\\"]\\\"), :fetch-opts {:n 20}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" or an expression:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [foo (str ?first-name \\\" \\\" ?last-name)]\\n  @foo)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value \\\" \\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}\"}, :path []} {:nextjournal/value \" Initial values for fields can be provided via an `:init` map, which should map\\n fields to values.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [foo (str ?first-name \\\" \\\" ?last-name)\\n            :init {?first-name \\\"Peter\\\"\\n                   ?last-name \\\"Rabbit\\\"}]\\n  @foo)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value \\\"Peter Rabbit\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}\"}, :path []} {:nextjournal/value \" Metadata like this can also be provided directly on fields, by wrapping the field\\n in a list and adding key-value pairs:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [foo (str (?first-name :init \\\"Peter\\\")\\n                     \\\" \\\"\\n                     (?last-name :init \\\"Rabbit\\\"))]\\n  @foo)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value \\\"Peter Rabbit\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}\"}, :path []} {:nextjournal/value \" A field can be used creatively to produce arbitrary output.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [cars (take ?number (repeat \\\"ðŸš™\\\"))\\n            :init {?number 3}]\\n  @cars)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value \\\"ðŸš™\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}} {:path [1], :nextjournal/value \\\"ðŸš™\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}} {:path [2], :nextjournal/value \\\"ðŸš™\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"(\\\", :closing-paren (\\\")\\\"), :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" Using an HTML slider:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(hiccup\\n  (with-form [cars (take ?number (repeat \\\"ðŸš™\\\"))\\n              :init {?number 10}]\\n    [:<>\\n     [:input {:type \\\"range\\\" :min \\\"1\\\" :max \\\"40\\\"\\n              :value @?number\\n              :on-change (fn [e]\\n                           (reset! ?number\\n                                   (js/parseInt (.. e -target -value))))}]\\n     [:div (str/join @cars)]]))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value {:reagent/var inside-out.notebook/reagent-view--1528428013}, :nextjournal/width :wide, :nextjournal/viewer {:render-fn #viewer-fn (fn render-var [{var :reagent/var}] (let [path (->> (str/split (str var) #\\\"[./]\\\") (mapv munge)) reagent-fn (applied-science.js-interop/get-in js/window path)] (when reagent-fn (v/html [:div.m-1 [reagent-fn]]))))}}\"}, :path [], :nextjournal/width :wide} {:nextjournal/value \" Fields can be used in expressions more than once:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form [?name\\n                   {:name ?name}\\n                   (->> (repeat ?name)\\n                        (take ?number)\\n                        (map str/upper-case))]]\\n  (reset! ?name \\\"Blythe\\\")\\n  (reset! ?number 3)\\n  @!form)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value \\\"Blythe\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value :name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 0 1], :nextjournal/value \\\"Blythe\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\"), :fetch-opts {:n 10}}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value \\\"BLYTHE\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}} {:path [2 1], :nextjournal/value \\\"BLYTHE\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}} {:path [2 2], :nextjournal/value \\\"BLYTHE\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"(\\\", :closing-paren (\\\")\\\" \\\"]\\\"), :fetch-opts {:n 20}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" ## Metadata\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Forms don't only return data. They also communicate with users and validate input. A \\\"field\\\"\\n is not just a piece of data, it's also information about what kind of data is acceptable,\\n where it should come from, what it should be called, and so on. We refer to all this as\\n \\\"metadata\\\" and have a few ways of providing it.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" 1. Inline metadata is when we wrap a field in a list, with key-value pairs. Eg:\\n `(?name :init \\\"Peter\\\")`\\n 2. A `:meta` option can supply metadata for multiple fields at once, eg\\n  `:meta {?name {:init \\\"Peter\\\"} ?email {:init \\\"rabbit@example.com\\\"}}`\\n 3. The `:init` and `:required` metadata fields have shorthand syntax as they are\\n    so commonly used.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" `:meta` syntax\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [form {:name ?name :email ?email}\\n            :meta {?name {:init \\\"Peter\\\"}\\n                   ?email {:init \\\"rabbit@example.com\\\"}}]\\n  @form)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :email, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value \\\"rabbit@example.com\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value \\\"Peter\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\"), :fetch-opts {:n 10}}}\", :nextjournal/viewer {:name :map}}, :path []} {:nextjournal/value \" shorthand syntax for `:required` and `:init`\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [form {:name ?name :email ?email}\\n            :required [?name ?email]\\n            :init {?name \\\"Peter\\\"\\n                   ?email \\\"rabbit@example.com\\\"}]\\n  @form)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :email, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value \\\"rabbit@example.com\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value \\\"Peter\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\"), :fetch-opts {:n 10}}}\", :nextjournal/viewer {:name :map}}, :path []} {:nextjournal/value \" ### Attribute metadata\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"\\n Metadata can also be defined for _attributes_ like `:person/name`, which are then\\n inferred for fields based on their position in a data structure:\\n 1. when a field is in the value position in a map, eg. `{<attribute> ?field}`,\\n 2. when a field is in the value position of a :db/add vector:\\n    `[:db/add <id> <attribute> ?field]`\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form [[:db/add 1 :person/name ?name]\\n                   {:pet/id ?pet-id}]]\\n  [(:attribute ?name)\\n   (:attribute ?pet-id)])\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value :person/name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1], :nextjournal/value :pet/id, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :closing-paren (\\\"]\\\"), :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" Instead of defining metadata for named fields, we can now add metadata for attributes:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form [[:db/add 1 :person/name ?name]]\\n            :meta {:person/name {:label \\\"Your name\\\"}}]\\n  (:label ?name))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value \\\"Your name\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}\"}, :path []} {:nextjournal/value \" All fields inherit metadata from the a global var `inside-out.forms/*global-meta*`.\\n This can be useful for attributes that are reused throughout an app.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" in ClojureScript, we would `set!` the var during app initialization:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"'(defn init []\\n   ;; your app's initialization code\\n   (set! inside-out.forms/*global-meta* my-attribute-metadata))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value defn, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}} {:path [1], :nextjournal/value init, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}} {:path [2], :nextjournal/value [], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :closing-paren (\\\"]\\\"), :fetch-opts {:n 20}}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value set!, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}} {:path [3 1], :nextjournal/value inside-out.forms/*global-meta*, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}} {:path [3 2], :nextjournal/value my-attribute-metadata, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"(\\\", :closing-paren (\\\")\\\" \\\")\\\"), :fetch-opts {:n 20}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"(\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" To show an example here, we'll use `binding` (not recommended for real-world use\\n due to limitations of dynamic vars in ClojureScript):\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(binding [forms/*global-meta* {:person/name {:label \\\"Your name\\\"}}]\\n  (with-form [!form [[:db/add 1 :person/name ?name]]]\\n    (:label ?name)))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value \\\"Your name\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}\"}, :path []} {:nextjournal/value \" We expect attribute-metadata to be most useful for things like labels and validators.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ## Component examples\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Here we define a \\\"managed\\\" text-input view that makes full use of a field's\\n methods and metadata. The forms library supplies handlers for change, blur, and\\n focus events so that this logic can be reused in your own components.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"#?(:cljs\\n   (defn managed-text-input\\n     \\\"A text-input element that reads metadata from a ?field to display appropriately\\\"\\n     [?field attrs]\\n     (let [messages (forms/visible-messages ?field)]\\n       [:<>\\n        [ui/input-text-element\\n         (merge {:placeholder (:label ?field)\\n                 :value @?field\\n                 :on-change (forms/change-handler ?field)\\n                 :on-blur (forms/blur-handler ?field)\\n                 :on-focus (forms/focus-handler ?field)\\n                 :class (when (:invalid (forms/types messages))\\n                          \\\"ring-2 ring-offset-2 ring-red-500 focus:ring-red-500\\\")}\\n                attrs)]\\n        (into [:div.mt-3] (map ui/view-message) messages)])))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:render-fn #viewer-fn (fn [_] (v/html [:span.cmt-default.inspected-value \\\"nil\\\"]))}}\"}, :path []} {:nextjournal/value \" Example with validation. `?name` is no required, so the field is valid until\\n the user starts typing.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(hiccup\\n  (with-form [form [[:db/add 1 :person/name ?name]]\\n              :meta {?name {:label \\\"Your full name\\\"\\n                            :validators [(forms/min-length 3)]}}]\\n\\n    [:form\\n     [managed-text-input ?name]\\n     [:pre (str \\\"valid? \\\" (forms/valid? form))]\\n     [:pre (str @form)]]))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value {:reagent/var inside-out.notebook/reagent-view-1343996710}, :nextjournal/width :wide, :nextjournal/viewer {:render-fn #viewer-fn (fn render-var [{var :reagent/var}] (let [path (->> (str/split (str var) #\\\"[./]\\\") (mapv munge)) reagent-fn (applied-science.js-interop/get-in js/window path)] (when reagent-fn (v/html [:div.m-1 [reagent-fn]]))))}}\"}, :path [], :nextjournal/width :wide} {:nextjournal/value \" ## Validation\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Validation is an important concern for forms. Fields may specify a list of `:validators`\\n (it does not matter if these are specified inline or via a registry). Validators return\\n messages, which are read via `(forms/messages ?field)`.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form [[:db/add 1 :person/name ?name]]\\n            :meta {?name {:validators [:required (forms/min-length 3)]}}]\\n\\n  (reset! ?name \\\"ma\\\")\\n  (forms/messages ?name))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value :content, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 0 1], :nextjournal/value \\\"Too short (min 3 chars)\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value :sym, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1 1], :nextjournal/value ?name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 2], :nextjournal/value [{:path [0 2 0], :nextjournal/value :type, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 2 1], :nextjournal/value :invalid, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\" \\\")\\\"), :fetch-opts {:n 10}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"(\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" Validators can depend on other fields in the form. Each validator is a function, which is passed\\n the field's current value, and a map of the other fields in the current form (these fields must be\\n dereferenced to read their values):\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn validate-child-age [value {:syms [?parent-age]}]\\n  (when (>= value @?parent-age)\\n    {:type :invalid\\n     :content \\\"Child must be younger than parent\\\"}))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value \\\"side_out.notebook$validate_child_age 0x4780f080 \\\\\\\"inside_out.notebook$validate_child_age@4780f080\\\\\\\"\\\", :nextjournal/viewer {:name :fn, :render-fn #viewer-fn (fn [x] (v/html [:span.inspected-value [:span.cmt-meta \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\", :nextjournal/viewer {:name :fn}}, :path []} {:nextjournal/value \"(with-form [!form [[:db/add 1 :parent/age ?parent-age]\\n                   {:db/id 2\\n                    :child/parent 1\\n                    :child/age (?child-age :validators [validate-child-age])}]]\\n  (reset! ?parent-age 10)\\n  (reset! ?child-age 20)\\n  (forms/messages ?child-age))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value :content, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 0 1], :nextjournal/value \\\"Child must be younger than parent\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value :sym, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1 1], :nextjournal/value ?child-age, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 2], :nextjournal/value [{:path [0 2 0], :nextjournal/value :type, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 2 1], :nextjournal/value :invalid, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\" \\\")\\\"), :fetch-opts {:n 10}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"(\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" A validator can be placed on the form itself by passing it as an option:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form [{:system/id 1\\n                    :phone/mobile ?mobile\\n                    :phone/landline ?landline}]\\n            :validators [(fn [_ {:syms [?mobile ?landline]}]\\n                           (when-not (or @?mobile @?landline)\\n                             {:type :invalid\\n                              :content \\\"At least one phone number must be supplied\\\"}))]]\\n  ;; form becomes valid after adding a value for ?mobile\\n  [(forms/valid? !form)\\n   (do (reset! ?mobile \\\"+49 555 5555555\\\")\\n       (forms/valid? !form))])\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value false, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-bool.inspected-value (str x)]))}} {:path [1], :nextjournal/value true, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-bool.inspected-value (str x)]))}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :closing-paren (\\\"]\\\"), :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" A `:required` option may be passed with a list of required fields\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form {:name ?name :email ?email :phone ?phone}\\n            :required [?name ?email ?phone]]\\n  (forms/messages !form :deep true))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value :content, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 0 1], :nextjournal/value \\\"Required\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value :sym, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1 1], :nextjournal/value ?name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 2], :nextjournal/value [{:path [0 2 0], :nextjournal/value :type, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 2 1], :nextjournal/value :invalid, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\"), :fetch-opts {:n 10}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value :content, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 0 1], :nextjournal/value \\\"Required\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1 1], :nextjournal/value [{:path [1 1 0], :nextjournal/value :sym, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 1 1], :nextjournal/value ?email, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1 2], :nextjournal/value [{:path [1 2 0], :nextjournal/value :type, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 2 1], :nextjournal/value :invalid, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\"), :fetch-opts {:n 10}}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value [{:path [2 0 0], :nextjournal/value :content, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [2 0 1], :nextjournal/value \\\"Required\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [2 1], :nextjournal/value [{:path [2 1 0], :nextjournal/value :sym, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [2 1 1], :nextjournal/value ?phone, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [2 2], :nextjournal/value [{:path [2 2 0], :nextjournal/value :type, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [2 2 1], :nextjournal/value :invalid, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\" \\\")\\\"), :fetch-opts {:n 10}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"(\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" Or, include `:required? true` in a field's metadata\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form {:name (?name :required? true)\\n                   :email ?email}\\n            :meta {?email {:required? true}}]\\n  (forms/messages !form :deep true))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value :content, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 0 1], :nextjournal/value \\\"Required\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value :sym, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1 1], :nextjournal/value ?name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 2], :nextjournal/value [{:path [0 2 0], :nextjournal/value :type, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 2 1], :nextjournal/value :invalid, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\"), :fetch-opts {:n 10}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value :content, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 0 1], :nextjournal/value \\\"Required\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1 1], :nextjournal/value [{:path [1 1 0], :nextjournal/value :sym, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 1 1], :nextjournal/value ?email, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1 2], :nextjournal/value [{:path [1 2 0], :nextjournal/value :type, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 2 1], :nextjournal/value :invalid, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\" \\\")\\\"), :fetch-opts {:n 10}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"(\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" fields can be used more than once in a form:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form [[:db/add 1 :person/pet ?pet-id]\\n                   [:db/add ?pet-id :pet/name ?pet-name]]]\\n  (reset! ?pet-id 2)\\n  (reset! ?pet-name \\\"Fido\\\")\\n  @!form)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :db/add, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value 1, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2], :nextjournal/value :person/pet, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 3], :nextjournal/value 2, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :closing-paren (\\\"]\\\"), :fetch-opts {:n 20}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :db/add, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value 2, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2], :nextjournal/value :pet/name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 3], :nextjournal/value \\\"Fido\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :closing-paren (\\\"]\\\" \\\"]\\\"), :fetch-opts {:n 20}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" ## Plural fields\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A plural field (eg. `:db.cardinality.many`) can be modeled by wrapping a field in a list containing\\n the `?field` symbol for the list, followed by the \\\"template\\\" for each child.\\n Add and remove fields using `forms/add-many!` and `forms/remove-many!`, passing\\n a map of _bindings_ for each child's fields:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form {:features (?features {:name (str/upper-case ?name)\\n                                         :enabled? ?enabled})}\\n            :meta {?enabled {:init true}}]\\n\\n  ;; add two child elements:\\n  (forms/add-many! ?features {'?name \\\"Paint\\\"}\\n                   {'?name \\\"Wheels\\\"\\n                    '?enabled false})\\n\\n  @?features)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value :enabled?, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 0 1], :nextjournal/value true, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-bool.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value :name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1 1], :nextjournal/value \\\"PAINT\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\"), :fetch-opts {:n 10}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value :enabled?, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 0 1], :nextjournal/value false, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-bool.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1 1], :nextjournal/value [{:path [1 1 0], :nextjournal/value :name, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 1 1], :nextjournal/value \\\"WHEELS\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\" \\\"]\\\"), :fetch-opts {:n 10}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" Calling `seq` or otherwise iterating over a \\\"plural\\\" field returns a list of its children,\\n whose bindings can be read from the field using their names (quoted symbols). When providing\\n `:initial-children` for a plural field, each child should be a map of bindings as shown below.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form (?features {:name (str/upper-case ?name)})\\n            :meta {?features {:init [{'?name \\\"Herman\\\"}\\n                                     {'?name \\\"Sally\\\"}]}}]\\n  ;; below, we destructure each ?feature using :syms to access its bindings\\n  (for [{:as ?feature :syms [?name]} ?features]\\n    @?name))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value \\\"Herman\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}} {:path [1], :nextjournal/value \\\"Sally\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"(\\\", :closing-paren (\\\")\\\"), :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" Children are removed by passing a child instance to `forms/remove-many!`.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form (?items {:position ?position})]\\n  ;; add two items\\n  (forms/add-many! ?items '{?position 1} '{?position 2})\\n  ;; remove the first item\\n  (forms/remove-many! (first ?items))\\n  ;; Only the second item remains:\\n  @!form)\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value :position, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 0 1], :nextjournal/value 2, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\" \\\"]\\\"), :fetch-opts {:n 10}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" Example using a :many field:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(hiccup\\n  (with-form [!form [[:db/add 1 :person/pets\\n                      ;; define a plural field by adding a :many key to the field.\\n                      ;; it should contain a \\\"template\\\" for each item in the list.\\n                      (?pets {:pet/id ?id\\n                              :pet/name (?name :init \\\"Fido\\\")})]]]\\n\\n    [:div\\n     [ui/show-code (str @!form)]\\n\\n     (doall\\n      ;; call (seq ?pets) to get a list of fields, which can be destructured using :syms\\n      ;; to get the child bindings.\\n      (for [{:as ?pet :syms [?id ?name]} ?pets]\\n        [:div.flex.items-center.my-2\\n         {:key @?id}\\n         [managed-text-input ?name {:placeholder \\\"Name\\\"}]\\n         [:div.text-red-500.hover:underline.hover:cursor-pointer.mx-3.font-bold\\n          ;; call forms/remove-many-child! to remove an item\\n          {:on-click #(forms/remove-many! ?pet)} \\\"X\\\"]]))\\n\\n     [:div.my-3.text-blue-500.hover:underline.hover:cursor-pointer\\n      ;; to add an item, call form/add-many-child! with ?pets and a map of bindings,\\n      ;; using quoted symbols for keys {'?field, value}\\n      {:on-click #(forms/add-many! ?pets {'?id (rand-int 1000)})} \\\"Add Pet\\\"]]))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value {:reagent/var inside-out.notebook/reagent-view--1846946441}, :nextjournal/width :wide, :nextjournal/viewer {:render-fn #viewer-fn (fn render-var [{var :reagent/var}] (let [path (->> (str/split (str var) #\\\"[./]\\\") (mapv munge)) reagent-fn (applied-science.js-interop/get-in js/window path)] (when reagent-fn (v/html [:div.m-1 [reagent-fn]]))))}}\"}, :path [], :nextjournal/width :wide} {:nextjournal/value \" To specify metadata targeting the children of a plural field, use the :child-meta key:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(with-form [!form {:animal-names (?names ?name)}\\n            :meta {?names {:child-meta\\n                           {:validators [(fn [value _]\\n                                           {:type :info\\n                                            :content value})]}}}]\\n  (forms/add-many! ?names '{?name \\\"Toad\\\"}\\n                   '{?name \\\"Frog\\\"})\\n  (->> (forms/messages ?names :deep true)\\n       (map :content)))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value \\\"Toad\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}} {:path [1], :nextjournal/value \\\"Frog\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"(\\\", :closing-paren (\\\")\\\"), :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" ## Validators\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A validator is a function that returns messages. Fields and forms can both have `:validators`.\\n\\n `(value, context) => [...message]`\\n\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Each message is a map containing:\\n - `:type`\\n   - `:invalid` implies an invalid value which cannot be persisted.\\n   - `:info` has no effect other than showing content to the user.\\n   - `:in-progress` shows a loading animation.\\n - `:content` (a string, or hiccup)\\n - `:visibility` (`#{:touched :focused :always}`)\\n\\n Examples:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"[{:type :info\\n  :content \\\"Instructions/hints for the user\\\"\\n  :when #{:always :focused :touched}} ;; default is :touched\\n {:type :invalid\\n  :content \\\"A value that should be rejected\\\"}\\n {:type :in-progress\\n  :content \\\"(optional) - a loading indicator should be displayed while this message is present\\\"}]\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value :content, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 0 1], :nextjournal/value \\\"Instructions/hints for the user\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value :type, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 1 1], :nextjournal/value :info, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 2], :nextjournal/value [{:path [0 2 0], :nextjournal/value :when, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 2 1], :nextjournal/value [{:path [0 2 1 0], :nextjournal/value :always, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 2 1 1], :nextjournal/value :focused, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [0 2 1 2], :nextjournal/value :touched, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"#{\\\", :closing-paren (\\\"}\\\" \\\"}\\\"), :fetch-opts {:n 20}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :fetch-opts {:n 10}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value :content, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 0 1], :nextjournal/value \\\"A value that should be rejected\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1 1], :nextjournal/value [{:path [1 1 0], :nextjournal/value :type, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [1 1 1], :nextjournal/value :invalid, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\"), :fetch-opts {:n 10}}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value [{:path [2 0 0], :nextjournal/value :content, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [2 0 1], :nextjournal/value \\\"(optional) - a loading indicator should be displayed while this message is present\\\", :nextjournal/viewer {:render-fn #viewer-fn v/quoted-string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [2 1], :nextjournal/value [{:path [2 1 0], :nextjournal/value :type, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}} {:path [2 1 1], :nextjournal/value :in-progress, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-atom.inspected-value (str x)]))}}], :nextjournal/viewer {:name :map-entry, :render-fn #viewer-fn (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:name :map, :render-fn #viewer-fn v/map-viewer, :opening-paren \\\"{\\\", :closing-paren (\\\"}\\\" \\\"]\\\"), :fetch-opts {:n 10}}}], :nextjournal/viewer {:render-fn #viewer-fn v/coll-viewer, :opening-paren \\\"[\\\", :fetch-opts {:n 20}}}\"}, :path []} {:nextjournal/value \" ## Server submission\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The `forms/submittable?` and `forms/watch-promise` functions facilitate submission of a form\\n to a remote endpoint.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" `forms/watch-promise` sets `:loading?` to true, clears any old remote messages, and then waits for\\n the promise to complete. Then `:loading?` is removed, and remote messages are set to the resolved value.\\n\\n The following example includes buttons that show how to handle a successful or failed response.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(hiccup\\n  (with-form [form {:name (?name :init \\\"Sue\\\")}]\\n    [:div\\n     [ui/input-text ?name {}]\\n     [:pre.text-xs.whitespace-pre-wrap (str @form)]\\n     (into [:div]\\n           (map ui/view-message (if (:loading? form)\\n                                  (forms/wrap-message \\\"Loading...\\\")\\n                                  (forms/visible-messages form))))\\n     [:button.bg-blue-500.text-white.p-3.m-3\\n      {:on-click\\n       #(forms/watch-promise form\\n          (p/let [name @?name\\n                  result (p/timeout 500)]\\n            (forms/clear! form)\\n            {:messages (str \\\"Thanks, \\\" name \\\"!\\\")}))}\\n      \\\"Submit-Success\\\"]\\n     [:button.bg-red-500.text-white.p-3.m-3\\n      {:on-click\\n       #(forms/watch-promise form\\n          (p/let [name @?name\\n                  result (p/timeout 500)]\\n            {:error (str \\\"Sorry \\\" name \\\", an error occurred.\\\")}))}\\n      \\\"Submit-Error\\\"]]))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value {:reagent/var inside-out.notebook/reagent-view--608412320}, :nextjournal/width :wide, :nextjournal/viewer {:render-fn #viewer-fn (fn render-var [{var :reagent/var}] (let [path (->> (str/split (str var) #\\\"[./]\\\") (mapv munge)) reagent-fn (applied-science.js-interop/get-in js/window path)] (when reagent-fn (v/html [:div.m-1 [reagent-fn]]))))}}\"}, :path [], :nextjournal/width :wide} {:nextjournal/value \" `forms/clear!` resets a form to its initial state\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(binding [forms/*global-meta* {:a {:init \\\"A\\\"}}]\\n  (with-form [!form {:a ?a\\n                     :b (?b :init \\\"B\\\")\\n                     :c ?c\\n                     :d (?d [?e (?f :init \\\"F\\\") ?nil]\\n                            :init [{'?e \\\"E\\\"}])}\\n              :meta {?c {:init \\\"C\\\"}\\n                     ?e {:init \\\"E\\\"}}]\\n    (= @!form\\n       (do (reset! ?a 1)\\n           (reset! ?b 2)\\n           (reset! ?c 3)\\n           (forms/add-many! ?d '{?e 4 ?f 5 ?nil 6})\\n           (forms/clear! !form)\\n           @!form))))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value true, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-bool.inspected-value (str x)]))}}\"}, :path []} {:nextjournal/value \" ## Functional usage\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A form can be called as a function, passing a map of bindings, to evaluate its expression:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def additions (forms/form (+ ?a ?b)))\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value \\\"#object[inside_out.forms.Field 0x6b65653e {:status :failed, :val #error {\\\\n :cause nil\\\\n :via\\\\n [{:type java.lang.NullPointerException\\\\n   :message nil\\\\n   :at [clojure.lang.Numbers ops \\\\\\\"Numbers.java\\\\\\\" 1095]}]\\\\n :trace\\\\n [[clojure.lang.Numbers ops \\\\\\\"Numbers.java\\\\\\\" 1095]\\\\n  [clojure.lang.Numbers add \\\\\\\"Numbers.java\\\\\\\" 155]\\\\n  [inside_out.notebook$fn__13970 invokeStatic \\\\\\\"NO_SOURCE_FILE\\\\\\\" 0]\\\\n  [inside_out.notebook$fn__13970 invoke \\\\\\\"NO_SOURCE_FILE\\\\\\\" 0]\\\\n  [inside_out.forms.Field deref \\\\\\\"forms.cljc\\\\\\\" 37]\\\\n  [clojure.core$deref invokeStatic \\\\\\\"core.clj\\\\\\\" 2337]\\\\n  [clojure.core$deref_as_map$fn__7523 invoke \\\\\\\"core_print.clj\\\\\\\" 441]\\\\n  [clojure.core$deref_as_map invokeStatic \\\\\\\"core_print.clj\\\\\\\" 441]\\\\n  [clojure.core$fn__7529 invokeStatic \\\\\\\"core_print.clj\\\\\\\" 459]\\\\n  [clojure.core$fn__7529 invoke \\\\\\\"core_print.clj\\\\\\\" 459]\\\\n  [clojure.lang.MultiFn invoke \\\\\\\"MultiFn.java\\\\\\\" 234]\\\\n  [clojure.core$pr_on invokeStatic \\\\\\\"core.clj\\\\\\\" 3675]\\\\n  [clojure.core$pr invokeStatic \\\\\\\"core.clj\\\\\\\" 3678]\\\\n  [clojure.core$pr invoke \\\\\\\"core.clj\\\\\\\" 3678]\\\\n  [clojure.lang.AFn applyToHelper \\\\\\\"AFn.java\\\\\\\" 154]\\\\n  [clojure.lang.RestFn applyTo \\\\\\\"RestFn.java\\\\\\\" 132]\\\\n  [clojure.core$apply invokeStatic \\\\\\\"core.clj\\\\\\\" 667]\\\\n  [clojure.core$pr_str invokeStatic \\\\\\\"core.clj\\\\\\\" 4760]\\\\n  [clojure.core$pr_str doInvoke \\\\\\\"core.clj\\\\\\\" 4760]\\\\n  [clojure.lang.RestFn invoke \\\\\\\"RestFn.java\\\\\\\" 408]\\\\n  [nextjournal.clerk.viewer$apply_viewer invokeStatic \\\\\\\"viewer.cljc\\\\\\\" 288]\\\\n  [nextjournal.clerk.viewer$apply_viewer invoke \\\\\\\"viewer.cljc\\\\\\\" 286]\\\\n  [nextjournal.clerk.viewer$wrapped_with_viewer invokeStatic \\\\\\\"viewer.cljc\\\\\\\" 312]\\\\n  [nextjournal.clerk.viewer$wrapped_with_viewer invoke \\\\\\\"viewer.cljc\\\\\\\" 299]\\\\n  [nextjournal.clerk.viewer$apply_viewer invokeStatic \\\\\\\"viewer.cljc\\\\\\\" 291]\\\\n  [nextjournal.clerk.viewer$apply_viewer invoke \\\\\\\"viewer.cljc\\\\\\\" 286]\\\\n  [nextjournal.clerk.viewer$wrapped_with_viewer invokeStatic \\\\\\\"viewer.cljc\\\\\\\" 312]\\\\n  [nextjournal.clerk.viewer$wrapped_with_viewer invoke \\\\\\\"viewer.cljc\\\\\\\" 299]\\\\n  [nextjournal.clerk.viewer$describe invokeStatic \\\\\\\"viewer.cljc\\\\\\\" 389]\\\\n  [nextjournal.clerk.viewer$describe invoke \\\\\\\"viewer.cljc\\\\\\\" 380]\\\\n  [nextjournal.clerk.viewer$describe invokeStatic \\\\\\\"viewer.cljc\\\\\\\" 386]\\\\n  [nextjournal.clerk.viewer$describe invoke \\\\\\\"viewer.cljc\\\\\\\" 380]\\\\n  [nextjournal.clerk.view$__GT_result invokeStatic \\\\\\\"view.clj\\\\\\\" 112]\\\\n  [nextjournal.clerk.view$__GT_result invoke \\\\\\\"view.clj\\\\\\\" 111]\\\\n  [nextjournal.clerk.view$describe_block invokeStatic \\\\\\\"view.clj\\\\\\\" 166]\\\\n  [nextjournal.clerk.view$describe_block invoke \\\\\\\"view.clj\\\\\\\" 153]\\\\n  [clojure.core$partial$fn__5910 invoke \\\\\\\"core.clj\\\\\\\" 2648]\\\\n  [clojure.core$map$fn__5931$fn__5932 invoke \\\\\\\"core.clj\\\\\\\" 2759]\\\\n  [clojure.lang.PersistentVector reduce \\\\\\\"PersistentVector.java\\\\\\\" 343]\\\\n  [clojure.core$transduce invokeStatic \\\\\\\"core.clj\\\\\\\" 6946]\\\\n  [clojure.core$into invokeStatic \\\\\\\"core.clj\\\\\\\" 6962]\\\\n  [clojure.core$into invoke \\\\\\\"core.clj\\\\\\\" 6950]\\\\n  [nextjournal.clerk.view$doc__GT_viewer$fn__11424 invoke \\\\\\\"view.clj\\\\\\\" 173]\\\\n  [clojure.core$update invokeStatic \\\\\\\"core.clj\\\\\\\" 6231]\\\\n  [clojure.core$update invoke \\\\\\\"core.clj\\\\\\\" 6223]\\\\n  [nextjournal.clerk.view$doc__GT_viewer invokeStatic \\\\\\\"view.clj\\\\\\\" 173]\\\\n  [nextjournal.clerk.view$doc__GT_viewer invoke \\\\\\\"view.clj\\\\\\\" 169]\\\\n  [nextjournal.clerk$file__GT_viewer invokeStatic \\\\\\\"clerk.clj\\\\\\\" 312]\\\\n  [nextjournal.clerk$file__GT_viewer invoke \\\\\\\"clerk.clj\\\\\\\" 309]\\\\n  [nextjournal.clerk$file__GT_viewer invokeStatic \\\\\\\"clerk.clj\\\\\\\" 311]\\\\n  [nextjournal.clerk$file__GT_viewer invoke \\\\\\\"clerk.clj\\\\\\\" 309]\\\\n  [clojure.core$juxt$fn__5891 invoke \\\\\\\"core.clj\\\\\\\" 2611]\\\\n  [clojure.core$map$fn__5931$fn__5932 invoke \\\\\\\"core.clj\\\\\\\" 2759]\\\\n  [clojure.lang.PersistentVector reduce \\\\\\\"PersistentVector.java\\\\\\\" 343]\\\\n  [clojure.core$transduce invokeStatic \\\\\\\"core.clj\\\\\\\" 6946]\\\\n  [clojure.core$into invokeStatic \\\\\\\"core.clj\\\\\\\" 6962]\\\\n  [clojure.core$into invoke \\\\\\\"core.clj\\\\\\\" 6950]\\\\n  [nextjournal.clerk$build_static_app_BANG_ invokeStatic \\\\\\\"clerk.clj\\\\\\\" 421]\\\\n  [nextjournal.clerk$build_static_app_BANG_ invoke \\\\\\\"clerk.clj\\\\\\\" 407]\\\\n  [user$publish_BANG_ invokeStatic \\\\\\\"user.clj\\\\\\\" 19]\\\\n  [user$publish_BANG_ invoke \\\\\\\"user.clj\\\\\\\" 16]\\\\n  [clojure.lang.AFn applyToHelper \\\\\\\"AFn.java\\\\\\\" 154]\\\\n  [clojure.lang.AFn applyTo \\\\\\\"AFn.java\\\\\\\" 144]\\\\n  [clojure.lang.Var applyTo \\\\\\\"Var.java\\\\\\\" 705]\\\\n  [clojure.core$apply invokeStatic \\\\\\\"core.clj\\\\\\\" 667]\\\\n  [clojure.core$apply invoke \\\\\\\"core.clj\\\\\\\" 662]\\\\n  [clojure.run.exec$exec invokeStatic \\\\\\\"exec.clj\\\\\\\" 48]\\\\n  [clojure.run.exec$exec doInvoke \\\\\\\"exec.clj\\\\\\\" 39]\\\\n  [clojure.lang.RestFn invoke \\\\\\\"RestFn.java\\\\\\\" 423]\\\\n  [clojure.run.exec$_main$fn__13299 invoke \\\\\\\"exec.clj\\\\\\\" 180]\\\\n  [clojure.run.exec$_main invokeStatic \\\\\\\"exec.clj\\\\\\\" 176]\\\\n  [clojure.run.exec$_main doInvoke \\\\\\\"exec.clj\\\\\\\" 139]\\\\n  [clojure.lang.RestFn applyTo \\\\\\\"RestFn.java\\\\\\\" 137]\\\\n  [clojure.lang.Var applyTo \\\\\\\"Var.java\\\\\\\" 705]\\\\n  [clojure.core$apply invokeStatic \\\\\\\"core.clj\\\\\\\" 667]\\\\n  [clojure.main$main_opt invokeStatic \\\\\\\"main.clj\\\\\\\" 514]\\\\n  [clojure.main$main_opt invoke \\\\\\\"main.clj\\\\\\\" 510]\\\\n  [clojure.main$main invokeStatic \\\\\\\"main.clj\\\\\\\" 664]\\\\n  [clojure.main$main doInvoke \\\\\\\"main.clj\\\\\\\" 616]\\\\n  [clojure.lang.RestFn applyTo \\\\\\\"RestFn.java\\\\\\\" 137]\\\\n  [clojure.lang.Var applyTo \\\\\\\"Var.java\\\\\\\" 705]\\\\n  [clojure.main main \\\\\\\"main.java\\\\\\\" 40]]}}]\\\", :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.inspected-value.whitespace-nowrap.cmt-default x]))}}\"}, :path []} {:nextjournal/value \"(additions '{?a 1 ?b 2})\", :nextjournal/viewer :code} {:nextjournal/viewer :clerk/result, :nextjournal/value {:nextjournal/edn \"{:path [], :nextjournal/value 3, :nextjournal/viewer {:render-fn #viewer-fn (fn [x] (v/html [:span.cmt-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :path []} {:nextjournal/value \" ## Implementation notes\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" ### Reagent\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" In ClojureScript, `with-form` uses [Reagent's](http://reagent-project.github.io)  `with-let` macro,\\n so that a form is created once (when a component mounts) and we can use the fields with input components.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" PRs are welcome for integrations other than Reagent. All that is required is a macro which behaves\\n like `with-let` (\\\"finally\\\" behaviour is not required). See `inside-out.reagent` for macro implementation.\\n\", :nextjournal/viewer :markdown}], :toc {:type :toc, :children [{:type :toc, :content [{:type :text, :text \"inside-out: a Clojure forms library\"}], :heading-level 1, :children [{:type :toc, :content [{:type :text, :text \"Syntax Quickstart\"}], :heading-level 2} {:type :toc, :content [{:type :text, :text \"Metadata\"}], :heading-level 2, :children [{:type :toc, :content [{:type :text, :text \"Attribute metadata\"}], :heading-level 3}]} {:type :toc, :content [{:type :text, :text \"Component examples\"}], :heading-level 2} {:type :toc, :content [{:type :text, :text \"Validation\"}], :heading-level 2} {:type :toc, :content [{:type :text, :text \"Plural fields\"}], :heading-level 2} {:type :toc, :content [{:type :text, :text \"Validators\"}], :heading-level 2} {:type :toc, :content [{:type :text, :text \"Server submission\"}], :heading-level 2} {:type :toc, :content [{:type :text, :text \"Functional usage\"}], :heading-level 2} {:type :toc, :content [{:type :text, :text \"Implementation notes\"}], :heading-level 2, :children [{:type :toc, :content [{:type :text, :text \"Reagent\"}], :heading-level 3}]}]}]}, :title \"inside-out: a Clojure forms library\"}, :nextjournal/viewer :clerk/notebook, :scope {:namespace :inside-out.notebook}}}, :path->url {\"dev/inside_out/notebook.cljc\" \"dev/inside_out/notebook.html\"}, :current-path \"dev/inside_out/notebook.cljc\"}")
app.init(opts)
</script></body></html>